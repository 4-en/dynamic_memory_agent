# from aiko.storage import SimpleMultiKnowledgeBase, KnowledgebaseQueryResult
from dma.core.retrieval_results import RetrievalResults, Query, QueryResult, RetrieverType
from dma.core import Conversation, Message
from .ranking import BaseRanker
import sentence_transformers
from dma.core import Memory

import os

# A memory retriever is a retriever with a dynamic memory that can be updated
# using results from the evaluator.
# Like the base retriever, it also retrieves information based on the queries generated.

class MemoryRetriever:
    """
    A retriever with a dynamic memory that can be updated using results from the evaluator.
    """
    
    def __init__(self, storage_name:str="memory", embedding_dim:int=384):
        """
        Initialize the memory retriever.
        
        Parameters
        ----------
        storage_name : str, optional
            The name of the storage, by default "memory"
        embedding_dim : int, optional
            The dimension of the embeddings, by default 384
        """

        self.knowledge_base = None
        self.embedder = None
        self.storage_name = storage_name
        self.embedding_dim = embedding_dim
    

    def save(self):
        if self.knowledge_base is not None:
            self.knowledge_base.save()


    def add_memories(self, memory:Memory | list[Memory]):
        """
        Add a memory to the knowledge base.
        
        Parameters
        ----------
        memory : Memory | list[Memory]
            The memory or list of memories to add.
        """
        
        if memory is None:
            return
        
        if isinstance(memory, list):
            for mem in memory:
                self.add_memory(mem)
            return



        content = memory.memory
        vector = self.embedder.encode(content, convert_to_numpy=True)

        # TODO: check for similar memories and either combine them or skip if same info

        # TODO: store the actual memory with metadata
        self.knowledge_base.insert(memory, vector)

    def retrieve(self, conversation:Conversation, queries:list[Query]) -> RetrievalResults:
        '''
        Retrieve information based on the queries generated by the evaluator.

        
        Parameters
        ----------
        conversation : Conversation
            The conversation to retrieve information for.
        queries : List[Query]
            A list of queries to retrieve information.
            
        Returns
        -------
        RetrievalResults
            The retrieval context containing the results of the retrieval operation.
        '''
        return self.retrieve_in_domains(conversation, queries)

    def retrieve_in_domains(self, conversation:Conversation, queries:list[Query]) -> RetrievalResults:
        """
        Retrieve information based on the queries generated by the evaluator.
        
        Parameters
        ----------
        conversation : Conversation
            The conversation to retrieve information for.
        queries : List[Query]
            A list of queries to retrieve information.
        
        Returns
        -------
        RetrievalResults
            The retrieval context containing the results of the retrieval operation.
        """
        
        # Initialize the retrieval results
        retrieval_results = RetrievalResults()
        
        query_embeddings = self.embedder.encode([query.query for query in queries], convert_to_numpy=True)

        # get the top k results from the knowledge base
        for query, query_embedding in zip(queries, query_embeddings):
            results: list[KnowledgebaseQueryResult] = []
            results = self.knowledge_base.query(query_embedding, k=5)

            for result in results:
                memory = Memory.from_dict(result.value, result.vector)
                query_result = QueryResult(
                    result=memory.memory,
                    query=query,
                    source=memory.source,
                    retriever_type=RetrieverType.MEMORY,
                    embedding=result.vector, 
                    score=result.score,
                    memory=memory
                )
                retrieval_results.add_result(query_result)

        return retrieval_results